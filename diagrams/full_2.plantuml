@startuml Алгоритм полного перебора за несколько дней

start

:Инициализация матрицы расстояний;
:Инициализация матрицы времени;
:Ввод начальной точки
(start_node);
:Инициализация временного лимита за день;
:Ввод количества дней визита;
:Ввод точек к посещению
(points_sequence);

:Создание пустого списка all_routes, который будет 
содержать все возможные маршруты для всех дней

Создание пустого списка optimal_routes, который будет 
содержать оптимальные маршруты для каждого дня

Множество из указанных точек, которые еще не были посещены: 
remaining_points = set(points_sequence);


while (Цикл по дням, в течение которых\nбудет производиться поиск маршрутов\n\nfor day in range(1, days + 1))
    :Создание пустого списка routes_info, 
    который будет содержать информацию о 
    найденных маршрутах для текущего дня;
    
    while (Цикл по возможным длинам маршрутов,\nначиная с одной точки и заканчивая всей\nпоследовательностью точек\n\nfor r in range(1, len(points_sequence) + 1))
        
        while (Цикл по всем возможным перестановкам\nточек для текущей длины маршрута\n\nfor route in itertools.permutations(remaining_points, r))
            :Добавление начальной и конечной точек 
            к текущему маршруту для создания замкнутого цикла
            
            route = (start_node,) + route + (start_node,);

            if (Маршурт допустим, учитывая временное ограничение?\n\nreturn True?\n(Запуск функции is_valid_route)) then (Да)
                'УДАЛИТЬ ИЛИ НЕТ?'
                '____________________________________________________________________________________________________________'
                :Запуск функции is_valid_route (проверка маршрута);
                
                :Инициализация переменной total_time для 
                хранения общего времени прохождения маршрута;

                while (Цикл перебора всех индексов точек маршрута кроме последней точки\n\nfor i in range(len(route) - 1))
                    :Добавление времени прохождения между текущей и следующей 
                    точками в общее время маршрута total_time 
                    c помощью матрицы времени
                    
                    total_time += matrix[route[i]][route[i+1]];

                    if (Общее время маршрута превышает\nустановленный дневной лимит?\n\ntotal_time > time_limit?) then (Да)
                        :Маршрут недопустим
                        
                        return False;
                    else (Нет)
                        :Маршрут допустим
                        
                        return True;
                    endif
                endwhile        
                '____________________________________________________________________________________________________________'

                :Вычисление общего времени для текущего 
                маршрута на основе матрицы времени
                
                route_time = sum(time_matrix[route[i]][route[i+1]] for i in range(len(route) - 1));

                :Добавление информации о текущем маршруте 
                (сам маршрут и время) в список routes_info
                
                routes_info.append((route, route_time));
            endif
        endwhile
        :Сортировка списка routes_info по убыванию, сначала по длине маршрута 
        (исключая начальную и конечную точки), а затем по времени
        
        routes_info.sort(key=lambda x: (len(x[0]) - 2, x[1]), reverse=True);
    endwhile
    
    while (Цикл по всем маршрутам и временам из\nотсортированного списка routes_info\n\nfor route, time in routes_info)
    :Добавление найденного маршрута и времени в 
    список всех маршрутов all_routes
    
    all_routes.append((route, time));
    endwhile

    if (Найдены какие-либо маршруты для текущего дня?\n\nroutes_info=True?) then (Да)
        :Выбор оптимального маршрута как первого 
        маршрута из отсортированного списка routes_info
        
        optimal_route = routes_info[0][0];

        :Удаление посещенных точек из множества remaining_points
        
        remaining_points -= set(optimal_route[1:-1]);

        :Добавление оптимального маршрута и 
        его времени в список optimal_routes
        
        optimal_routes.append((optimal_route, routes_info[0][1]));

    else (Нет)
    endif
endwhile

:Создание списка variants, содержащего все возможные 
варианты маршрутов на протяжении нескольких дней. 
Каждый вариант представляет собой комбинацию маршрутов 
из all_routes для каждого дня. days - количество дней

variants = list(itertools.permutations(all_routes, days));

:Нахождение оптимального варианта маршрутов среди 
уникальных вариантов unique_variants, 
используя функцию find_optimal_variant.
Создание множества unique_variants, содержащего 
только уникальные варианты маршрутов, 
для которых не происходит повторение точек, 
используя функцию check_point_repetition;

:Запуск функции check_point_repetition;
:Создание пустого множества visited_points, 
которое будет использоваться для отслеживания 
посещенных точек
visited_points = set();
while (Цикл перебора всех маршрутов в варианте маршрутов\n\nfor route, _ in variant)

    while (Цикл перебора всех точек в текущем маршруте,\nисключая начальную и конечную точки\n\nfor point in route[1:-1])
    
    if (Текущая точка была посещена?\n\npoint in visited_points?) then (Да)
        :return True;
        :Добавление текущей точки в множество visited_points, 
        чтобы отметить ее как посещенную
        
        visited_points.add(point);
    else (Нет)
        :return False;
    endif

    endwhile
endwhile
:Завершение функции check_point_repetition;


:Запуск функции find_optimal_variant;
:Инициализация переменной max_points, 
которая будет использоваться для отслеживания 
максимального количества точек в оптимальном варианте

max_points = 0;
:Инициализация переменной min_total_time равной бесконечности, 
которая будет использоваться для отслеживания минимального 
общего времени в оптимальном варианте

min_total_time = float('inf');
:Инициализация переменной optimal_variant как пустого списка, 
который будет использоваться для хранения оптимального 
варианта маршрутов

optimal_variant = [];

while (Цикл перебора всех вариантов маршрутов\n\nfor variant in variants)
    :Вычисление общего времени для текущего варианта 
    маршрутов суммой времени каждого маршрута
    
    total_time = sum(time for _, time in variant);

    :Вычисление количества точек в первом маршруте 
    текущего варианта маршрутов, исключая начальную 
    и конечную точки
    
    points = sum(1 for point in variant[0][0][1:-1]);

    if (Текущий вариант содержит больше точек или\nон содержит то же количество точек,\nно при этом общее время меньше?\n\npoints > max_points or\n(points == max_points and total_time < min_total_time)?) then (Да)
            :max_points = points;
            :min_total_time = total_time;
            :optimal_variant = variant;

        else (Нет)
    endif
endwhile
:Завершение функции find_optimal_variant;

if (Оптимальный вариант маршрутов найден?\n\noptimal_variant=True?) then (Да)
    :Вывод: ''Решение полным 
    перебором за несколько дней:'';

    :Вычисление общего времени всех 
    маршрутов в оптимальном варианте
    
    total_time = sum(time for _, time in optimal_variant);

    if (Общее время=0?\n\ntotal_time == 0?) then (Да)
        :Вывод: ''Оптимальный маршрут не найден'';

        else (Нет)
        while (Цикл перебора всех маршрутов и\nвремени в оптимальном варианте,\nиспользуя функцию enumerate для\nдобавления индекса дня начиная с 1\n\nfor i, (route, time) in enumerate(optimal_variant, start=1))
        :Вычисление общего расстояния для текущего маршрута, 
        суммируя расстояния между каждой парой последовательных точек
        
        total_distance = sum(distance_matrix[route[i-1]][route[i]] for i in range(1, len(route)));
        
        :Вывод информации о текущем маршруте, 
        включая день, сам маршрут, время и общее расстояние;
        endwhile

        :Создание пустого множества optimal_points, 
        которое будет содержать все точки, 
        учтенные в оптимальном решении
        
        optimal_points = set();

        while (Цикл перебора всех маршрутов в оптимальном варианте\n\nfor route, _ in optimal_variant)
        :Обновление множества optimal_points, 
        добавляя все точки из текущего маршрута, 
        исключая начальную и конечную точки
        
        optimal_points.update(route[1:-1]);
        endwhile

        :Вычисление множества missing_points, 
        содержащего точки из points_sequence, 
        которые не учтены в оптимальном решении
        
        missing_points = set(points_sequence) - optimal_points;

        if (Есть ли пропущенные точки\nв оптимальном решении?\n\nmissing_points=True?) then (Да)
            :Вывод несоблюденных точек;
            else (Нет)
        endif
    endif
    
    else (Нет)
        :Вывод: ''Невозможно построить 
        маршруты полным перебором.

        Попробуйте уменьшить количество 
        точек или увеличить дни пребывания'';
endif
stop

@enduml
